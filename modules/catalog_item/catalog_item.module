<?php

/**
 * @file
 * The core module that allows catalog items to be submitted to the site.
 *
 * Modules and scripts may programmatically submit catalog_items using the usual form
 * API pattern.
 */

use Drupal\Component\Utility\Environment;
use Drupal\Component\Utility\Xss;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Database\Query\AlterableInterface;
use Drupal\Core\Database\Query\SelectInterface;
use Drupal\Core\Database\StatementInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Render\Element;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Url;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\language\ConfigurableLanguageInterface;
use Drupal\catalog_item\Entity\CatalogItem;
use Drupal\catalog_item\Entity\Catalog;
use Drupal\catalog_item\CatalogItemInterface;
use Drupal\catalog_item\CatalogInterface;
use Drupal\user\UserInterface;
use Drupal\taxonomy\Entity\Term;

// /**
//  * Denotes that the catalog_item is not published.
//  *
//  * @deprecated in drupal:8.?.? and is removed from drupal:9.0.0.
//  *   Use \Drupal\catalog_item\CatalogItemInterface::NOT_PUBLISHED instead.
//  *
//  * @see https://www.drupal.org/catalog_item/2316145
//  */
// const CATALOGITEM_NOT_PUBLISHED = 0;

// /**
//  * Denotes that the catalog_item is published.
//  *
//  * @deprecated in drupal:8.?.? and is removed from drupal:9.0.0.
//  *   Use \Drupal\catalog_item\CatalogItemInterface::PUBLISHED instead.
//  *
//  * @see https://www.drupal.org/catalog_item/2316145
//  */
// const CATALOGITEM_PUBLISHED = 1;

// /**
//  * Denotes that the catalog_item is not promoted to the front page.
//  *
//  * @deprecated in drupal:8.?.? and is removed from drupal:9.0.0.
//  *   Use \Drupal\catalog_item\CatalogItemInterface::NOT_PROMOTED instead.
//  *
//  * @see https://www.drupal.org/catalog_item/2316145
//  */
// const CATALOGITEM_NOT_PROMOTED = 0;

// /**
//  * Denotes that the catalog_item is promoted to the front page.
//  *
//  * @deprecated in drupal:8.?.? and is removed from drupal:9.0.0.
//  *   Use \Drupal\catalog_item\CatalogItemInterface::PROMOTED instead.
//  *
//  * @see https://www.drupal.org/catalog_item/2316145
//  */
// const CATALOGITEM_PROMOTED = 1;

// /**
//  * Denotes that the catalog_item is not sticky at the top of the page.
//  *
//  * @deprecated in drupal:8.?.? and is removed from drupal:9.0.0.
//  *   Use \Drupal\catalog_item\CatalogItemInterface::NOT_STICKY instead.
//  *
//  * @see https://www.drupal.org/catalog_item/2316145
//  */
// const CATALOGITEM_NOT_STICKY = 0;

// /**
//  * Denotes that the catalog_item is sticky at the top of the page.
//  *
//  * @deprecated in drupal:8.?.? and is removed from drupal:9.0.0.
//  *   Use \Drupal\catalog_item\CatalogItemInterface::STICKY instead.
//  *
//  * @see https://www.drupal.org/catalog_item/2316145
//  */
// const CATALOGITEM_STICKY = 1;

/**
 * Implements hook_help().
 */
function catalog_item_help($route_name, RouteMatchInterface $route_match) {
  // Remind site administrators about the {catalog_item_access} table being flagged
  // for rebuild. We don't need to issue the message on the confirm form, or
  // while the rebuild is being processed.
  if ($route_name != 'catalog_item.configure_rebuild_confirm' && $route_name != 'system.batch_page.normal' && $route_name != 'help.page.catalog_item' && $route_name != 'help.main'
    && \Drupal::currentUser()->hasPermission('access administration pages') && catalog_item_access_needs_rebuild()) {
    if ($route_name == 'system.status') {
      $message = t('The catalog access permissions need to be rebuilt.');
    }
    else {
      $message = t('The catalog access permissions need to be rebuilt. <a href=":catalog_item_access_rebuild">Rebuild permissions</a>.', [':catalog_item_access_rebuild' => Url::fromRoute('catalog_item.configure_rebuild_confirm')->toString()]);
    }
    \Drupal::messenger()->addError($message);
  }

  switch ($route_name) {
    case 'help.page.catalog_item':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The CatalogItem module manages the creation, editing, deletion, settings, and display of the main site catalog. Catalog items managed by the CatalogItem module are typically displayed as pages on your site, and include a title, some meta-data (author, creation time, catalog, etc.), and optional fields containing text or other data (fields are managed by the <a href=":field">Field module</a>). For more information, see the <a href=":catalog_item">online documentation for the CatalogItem module</a>.', [':catalog_item' => 'https://www.drupal.org/documentation/modules/catalog_item', ':field' => Url::fromRoute('help.page', ['name' => 'field'])->toString()]) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Creating catalog items') . '</dt>';
      $output .= '<dd>' . t('When new catalog items are created, the CatalogItem module records basic information about the catalog items, including the author, date of creation, and the <a href=":catalog">Catalog</a> Type. It also manages the <em>publishing options</em>, which define whether or not the content is published, promoted to the front page of the site, and/or sticky at the top of content lists. Default settings can be configured for each <a href=":catalog">catalog</a> on your site.', [':catalog' => Url::fromRoute('entity.catalog.collection')->toString()]) . '</dd>';
      $output .= '<dt>' . t('Creating custom catalogs') . '</dt>';
      $output .= '<dd>' . t('The CatalogItem module gives users with the <em>Administer catalogs</em> permission the ability to <a href=":content-new">create new catalogs</a> in addition to the default ones already configured. Creating custom catalogs gives you the flexibility to add <a href=":field">fields</a> and configure default settings that suit the differing needs of various site content.', [':content-new' => Url::fromRoute('catalog_item.catalog_add')->toString(), ':field' => Url::fromRoute('help.page', ['name' => 'field'])->toString()]) . '</dd>';
      $output .= '<dt>' . t('Administering content') . '</dt>';
      $output .= '<dd>' . t('The <a href=":content">Catalog</a> page lists your content, allowing you add new content, filter, edit or delete existing content, or perform bulk operations on existing content.', [':content' => Url::fromRoute('catalog_item.admin')->toString()]) . '</dd>';
      $output .= '<dt>' . t('Creating revisions') . '</dt>';
      $output .= '<dd>' . t('The CatalogItem module also enables you to create multiple versions of any content, and revert to older versions using the <em>Revision information</em> settings.') . '</dd>';
      $output .= '<dt>' . t('User permissions') . '</dt>';
      $output .= '<dd>' . t('The CatalogItem module makes a number of permissions available for each catalog, which can be set by role on the <a href=":permissions">permissions page</a>.', [':permissions' => Url::fromRoute('user.admin_permissions', [], ['fragment' => 'module-catalog_item'])->toString()]) . '</dd>';
      $output .= '</dl>';
      return $output;

    case 'catalog_item.catalog_add':
      return '<p>' . t('Individual catalogs can have different fields, behaviors, and permissions assigned to them.') . '</p>';

    case 'entity.entity_form_display.catalog_item.default':
    case 'entity.entity_form_display.catalog_item.form_mode':
      $type = $route_match->getParameter('catalog');
      return '<p>' . t('Content items can be edited using different form modes. Here, you can define which fields are shown and hidden when %type content is edited in each form mode, and define how the field form widgets are displayed in each form mode.', ['%type' => $type->label()]) . '</p>';

    case 'entity.entity_view_display.catalog_item.default':
    case 'entity.entity_view_display.catalog_item.view_mode':
      $type = $route_match->getParameter('catalog');
      return '<p>' . t('Content items can be displayed using different view modes: Teaser, Full content, Print, RSS, etc. <em>Teaser</em> is a short format that is typically used in lists of multiple content items. <em>Full content</em> is typically used when the content is displayed on its own page.') . '</p>' .
        '<p>' . t('Here, you can define which fields are shown and hidden when %type content is displayed in each view mode, and define how the fields are displayed in each view mode.', ['%type' => $type->label()]) . '</p>';

    case 'entity.catalog_item.version_history':
      return '<p>' . t('Revisions allow you to track differences between multiple versions of your content, and revert to older versions.') . '</p>';

    case 'entity.catalog_item.edit_form':
      $catalog_item = $route_match->getParameter('catalog_item');
      $type = Catalog::load($catalog_item->getCatalog());
      $help = $type->getHelp();
      return (!empty($help) ? Xss::filterAdmin($help) : '');

    case 'catalog_item.add':
      $type = $route_match->getParameter('catalog');
      $help = $type->getHelp();
      return (!empty($help) ? Xss::filterAdmin($help) : '');
  }
}

/**
 * Implements hook_theme().
 */
function catalog_item_theme() {
  return [
    'catalog_item' => [
      'render element' => 'elements',
    ],
    'catalog_item_add_list' => [
      'variables' => ['content' => NULL],
    ],
    'catalog_item_edit_form' => [
      'render element' => 'form',
    ],
    'field__catalog_item__title' => [
      'base hook' => 'field',
    ],
    'field__catalog_item__uid' => [
      'base hook' => 'field',
    ],
    'field__catalog_item__created' => [
      'base hook' => 'field',
    ],
  ];
}

/**
 * Implements hook_entity_view_display_alter().
 */
function catalog_item_entity_view_display_alter(EntityViewDisplayInterface $display, $context) {
  if ($context['entity_type'] == 'catalog_item') {
    // Hide field labels in search index.
    if ($context['view_mode'] == 'search_index') {
      foreach ($display->getComponents() as $name => $options) {
        if (isset($options['label'])) {
          $options['label'] = 'hidden';
          $display->setComponent($name, $options);
        }
      }
    }
  }
}

/**
 * Gathers a listing of links to catalog_items.
 *
 * @param \Drupal\Core\Database\StatementInterface $result
 *   A database result object from a query to fetch catalog_item entities. If your
 *   query joins the {comment_entity_statistics} table so that the comment_count
 *   field is available, a title attribute will be added to show the number of
 *   comments.
 * @param $title
 *   (optional) A heading for the resulting list.
 *
 * @return array|false
 *   A renderable array containing a list of linked catalog_item titles fetched from
 *   $result, or FALSE if there are no rows in $result.
 */
function catalog_item_title_list(StatementInterface $result, $title = NULL) {
  $items = [];
  $num_rows = FALSE;
  $nids = [];
  foreach ($result as $row) {
    // Do not use $catalog_item->label() or $catalog_item->toUrl() here, because we only have
    // database rows, not actual catalog_items.
    $nids[] = $row->nid;
    $options = !empty($row->comment_count) ? ['attributes' => ['title' => \Drupal::translation()->formatPlural($row->comment_count, '1 comment', '@count comments')]] : [];
    $items[] = Link::fromTextAndUrl($row->title, Url::fromRoute('entity.catalog_item.canonical', ['catalog_item' => $row->nid], $options))->toString();
    $num_rows = TRUE;
  }

  return $num_rows ? ['#theme' => 'item_list__catalog_item', '#items' => $items, '#title' => $title, '#cache' => ['tags' => Cache::mergeTags(['catalog_item_list'], Cache::buildTags('catalog_item', $nids))]] : FALSE;
}

/**
 * Determines the type of marker to be displayed for a given catalog_item.
 *
 * @param int $nid
 *   CatalogItem ID whose history supplies the "last viewed" timestamp.
 * @param int $timestamp
 *   Time which is compared against catalog_item's "last viewed" timestamp.
 *
 * @return int
 *   One of the MARK constants.
 */
function catalog_item_mark($nid, $timestamp) {

  $cache = &drupal_static(__FUNCTION__, []);

  if (\Drupal::currentUser()->isAnonymous() || !\Drupal::moduleHandler()->moduleExists('history')) {
    return MARK_READ;
  }
  if (!isset($cache[$nid])) {
    $cache[$nid] = history_read($nid);
  }
  if ($cache[$nid] == 0 && $timestamp > HISTORY_READ_LIMIT) {
    return MARK_NEW;
  }
  elseif ($timestamp > $cache[$nid] && $timestamp > HISTORY_READ_LIMIT) {
    return MARK_UPDATED;
  }
  return MARK_READ;
}


/**
 * Returns a list of available catalog_item type names.
 *
 * This list can include types that are queued for addition or deletion.
 *
 * @return string[]
 *   An array of catalog_item type labels, keyed by the catalog_item type name.
 */
function catalog_get_names() {
  return array_map(function ($bundle_info) {
    return $bundle_info['label'];
  }, \Drupal::service('entity_type.bundle.info')->getBundleInfo('catalog_item'));
}

/**
 * Returns the catalog_item type label for the passed catalog_item.
 *
 * @param \Drupal\catalog_item\CatalogItemInterface $catalog_item
 *   A catalog_item entity to return the catalog_item type's label for.
 *
 * @return string|false
 *   The catalog_item type label or FALSE if the catalog_item type is not found.
 *
 * @todo Add this as generic helper method for config entities representing
 *   entity bundles.
 */
function catalog_item_get_catalog_label(CatalogItemInterface $catalog_item) {
  $type = Catalog::load($catalog_item->bundle());
  return $type ? $type->label() : FALSE;
}

/**
 * Description callback: Returns the catalog_item type description.
 *
 * @param \Drupal\catalog_item\CatalogInterface $catalog
 *   The catalog_item type object.
 *
 * @return string
 *   The catalog_item type description.
 */
function catalog_get_description(CatalogInterface $catalog) {
  return $catalog->getDescription();
}


/**
 * Adds the default description field to a catalog_item type.
 *
 * @param \Drupal\catalog_item\CatalogInterface $type
 *   A catalog_item type object.
 * @param string $label
 *   (optional) The label for the description instance.
 *
 * @return \Drupal\field\Entity\FieldConfig
 *   A Description field object.
 */
function catalog_item_add_description_field(CatalogInterface $type, $label = 'Description') {
  \Drupal::logger('catalog_importer')->notice('catalog_item_add_description_field....');
  // Add or remove the description field, as needed.
  $field_storage = FieldStorageConfig::loadByName('catalog_item', 'description');
  $field = FieldConfig::loadByName('catalog_item', $type->id(), 'description');
  if (empty($field)) {
    \Drupal::logger('catalog_importer')->notice('catalog_item_add_description_field is empty....');
    $field = FieldConfig::create([
      'field_name' => 'description',
      'field_storage' => $field_storage,
      'bundle' => $type->id(),
      'label' => $label,
      'settings' => ['display_summary' => TRUE],
    ]);
    $field->save();
    \Drupal::logger('catalog_importer')->notice('catalog_item_add_description_field mane is %name', array(
      '%name' => $field->getName()
    ));
    /** @var \Drupal\Core\Entity\EntityDisplayRepositoryInterface $display_repository */
    $display_repository = \Drupal::service('entity_display.repository');

    // Assign widget settings for the default form mode.
    $display_repository->getFormDisplay('catalog_item', $type->id())
      ->setComponent('description', [
        'type' => 'text_textarea_with_summary',
      ])
      ->save();

    // Assign display settings for the 'default' and 'teaser' view modes.
    $display_repository->getViewDisplay('catalog_item', $type->id())
      ->setComponent('description', [
        'label' => 'hidden',
        'type' => 'text_default',
      ])
      ->save();

    // The teaser view mode is created by the Standard profile and therefore
    // might not exist.
    $view_modes = \Drupal::service('entity_display.repository')->getViewModes('catalog_item');
    if (isset($view_modes['teaser'])) {
      $display_repository->getViewDisplay('catalog_item', $type->id(), 'teaser')
        ->setComponent('description', [
          'label' => 'hidden',
          'type' => 'text_summary_or_trimmed',
        ])
        ->save();
    }
  }

  return $field;
}

/**
 * Implements hook_entity_extra_field_info().
 */
function catalog_item_entity_extra_field_info() {
  $extra = [];
  $description = t('CatalogItem module element');
  foreach (Catalog::loadMultiple() as $bundle) {
    $extra['catalog_item'][$bundle->id()]['display']['links'] = [
      'label' => t('Links'),
      'description' => $description,
      'weight' => 100,
      'visible' => TRUE,
    ];
  }

  return $extra;
}

/**
 * Updates all catalog_items of one type to be of another type.
 *
 * @param string $old_catalog
 *   The current catalog_item type of the catalog_items.
 * @param string $new_catalog
 *   The new catalog_item type of the catalog_items.
 *
 * @return
 *   The number of catalog_items whose catalog_item type field was modified.
 */
function catalog_update_catalog_items($old_catalog, $new_catalog) {
  return \Drupal::entityTypeManager()->getStorage('catalog_item')->changeCatalog($old_catalog, $new_catalog);
}

// /**
//  * Loads catalog_item entities from the database.
//  *
//  * This function should be used whenever you need to load more than one catalog_item
//  * from the database. CatalogItems are loaded into memory and will not require database
//  * access if loaded again during the same page request.
//  *
//  * @param array $nids
//  *   (optional) An array of entity IDs. If omitted, all entities are loaded.
//  * @param bool $reset
//  *   (optional) Whether to reset the internal catalog_item_load() cache.  Defaults to
//  *   FALSE.
//  *
//  * @return \Drupal\catalog_item\CatalogItemInterface[]
//  *   An array of catalog_item entities indexed by nid.
//  *
//  * @deprecated in drupal:8.0.0 and is removed from drupal:9.0.0. Use
//  *   \Drupal\catalog_item\Entity\CatalogItem::loadMultiple().
//  *
//  * @see https://www.drupal.org/catalog_item/2266845
//  */
// function catalog_item_load_multiple(array $nids = NULL, $reset = FALSE) {
//   @trigger_error('catalog_item_load_multiple() is deprecated in Drupal 8.0.0 and will be removed before Drupal 9.0.0. Use \Drupal\catalog_item\Entity\CatalogItem::loadMultiple(). See https://www.drupal.org/catalog_item/2266845', E_USER_DEPRECATED);
//   if ($reset) {
//     \Drupal::entityTypeManager()->getStorage('catalog_item')->resetCache($nids);
//   }
//   return CatalogItem::loadMultiple($nids);
// }

// /**
//  * Loads a catalog_item entity from the database.
//  *
//  * @param int $nid
//  *   The catalog_item ID.
//  * @param bool $reset
//  *   (optional) Whether to reset the catalog_item_load_multiple() cache. Defaults to
//  *   FALSE.
//  *
//  * @return \Drupal\catalog_item\CatalogItemInterface|null
//  *   A fully-populated catalog_item entity, or NULL if the catalog_item is not found.
//  *
//  * @deprecated in drupal:8.0.0 and is removed from drupal:9.0.0. Use
//  *   \Drupal\catalog_item\Entity\CatalogItem::load().
//  *
//  * @see https://www.drupal.org/catalog_item/2266845
//  */
// function catalog_item_load($nid = NULL, $reset = FALSE) {
//   @trigger_error('catalog_item_load() is deprecated in Drupal 8.0.0 and will be removed before Drupal 9.0.0. Use \Drupal\catalog_item\Entity\CatalogItem::load(). See https://www.drupal.org/catalog_item/2266845', E_USER_DEPRECATED);
//   if ($reset) {
//     \Drupal::entityTypeManager()->getStorage('catalog_item')->resetCache([$nid]);
//   }
//   return CatalogItem::load($nid);
// }

/**
 * Loads a catalog_item revision from the database.
 *
 * @param int $vid
 *   The catalog_item revision id.
 *
 * @return \Drupal\catalog_item\CatalogItemInterface|null
 *   A fully-populated catalog_item entity, or NULL if the catalog_item is not found.
 */
function catalog_item_revision_load($vid = NULL) {
  return \Drupal::entityTypeManager()->getStorage('catalog_item')->loadRevision($vid);
}

/**
 * Deletes a catalog_item revision.
 *
 * @param int $revision_id
 *   The revision ID to delete.
 */
function catalog_item_revision_delete($revision_id) {
  \Drupal::entityTypeManager()->getStorage('catalog_item')->deleteRevision($revision_id);
}

/**
 * Checks whether the current page is the full page view of the passed-in catalog_item.
 *
 * @param \Drupal\catalog_item\CatalogItemInterface $catalog_item
 *   A catalog_item entity.
 *
 * @return int|false
 *   The ID of the catalog_item if this is a full page view, otherwise FALSE.
 */
function catalog_item_is_page(CatalogItemInterface $catalog_item) {
  $route_match = \Drupal::routeMatch();
  if ($route_match->getRouteName() == 'entity.catalog_item.canonical') {
    $page_catalog_item = $route_match->getParameter('catalog_item');
  }
  return (!empty($page_catalog_item) ? $page_catalog_item->id() == $catalog_item->id() : FALSE);
}

/**
 * Prepares variables for list of available catalog_item type templates.
 *
 * Default template: catalog_item-add-list.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - content: An array of catalogs.
 *
 * @see \Drupal\catalog_item\Controller\CatalogItemController::addPage()
 */
function template_preprocess_catalog_item_add_list(&$variables) {
  $variables['catalogs'] = [];
  if (!empty($variables['content'])) {
    foreach ($variables['content'] as $type) {
      $variables['catalogs'][$type->id()] = [
        'type' => $type->id(),
        'add_link' => Link::fromTextAndUrl($type->label(), Url::fromRoute('catalog_item.add', ['catalg' => $type->id()]))->toString(),
        'description' => [
          '#markup' => $type->getDescription(),
        ],
      ];
    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for HTML document templates.
 */
function catalog_item_preprocess_html(&$variables) {
  // If on an individual catalog_item page or catalog_item preview page, add the catalog_item type to
  // the body classes.
  if (($catalog_item = \Drupal::routeMatch()->getParameter('catalog_item')) || ($catalog_item = \Drupal::routeMatch()->getParameter('catalog_item_preview'))) {
    if ($catalog_item instanceof CatalogItemInterface) {
      $variables['catalog'] = $catalog_item->getCatalog();
    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for block templates.
 */
function catalog_item_preprocess_block(&$variables) {
  if ($variables['configuration']['provider'] == 'catalog_item') {
    switch ($variables['elements']['#plugin_id']) {
      case 'catalog_item_syndicate_block':
        $variables['attributes']['role'] = 'complementary';
        break;
    }
  }
}

/**
 * Implements hook_theme_suggestions_HOOK().
 */
function catalog_item_theme_suggestions_catalog_item(array $variables) {
  $suggestions = [];
  $catalog_item = $variables['elements']['#catalog_item'];
  $sanitized_view_mode = strtr($variables['elements']['#view_mode'], '.', '_');

  $suggestions[] = 'catalog_item__' . $sanitized_view_mode;
  $suggestions[] = 'catalog_item__' . $catalog_item->bundle();
  $suggestions[] = 'catalog_item__' . $catalog_item->bundle() . '__' . $sanitized_view_mode;
  $suggestions[] = 'catalog_item__' . $catalog_item->id();
  $suggestions[] = 'catalog_item__' . $catalog_item->id() . '__' . $sanitized_view_mode;

  return $suggestions;
}

/**
 * Prepares variables for catalog_item templates.
 *
 * Default template: catalog_item.html.twig.
 *
 * Most themes use their own copy of catalog_item.html.twig. The default is located
 * inside "/core/modules/catalog_item/templates/catalog_item.html.twig". Look in there for the
 * full list of variables.
 *
 * By default this function performs special preprocessing of some base fields
 * so they are available as variables in the template. For example 'title'
 * appears as 'label'. This preprocessing is skipped if:
 * - a module makes the field's display configurable via the field UI by means
 *   of BaseFieldDefinition::setDisplayConfigurable()
 * - AND the additional entity type property
 *   'enable_base_field_custom_preprocess_skipping' has been set using
 *   hook_entity_type_build().
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An array of elements to display in view mode.
 *   - catalog_item: The catalog_item object.
 *   - view_mode: View mode; e.g., 'full', 'teaser', etc.
 *
 * @see hook_entity_type_build()
 * @see \Drupal\Core\Field\BaseFieldDefinition::setDisplayConfigurable()
 */
function template_preprocess_catalog_item(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  // Provide a distinct $teaser boolean.
  $variables['teaser'] = $variables['view_mode'] == 'teaser';
  $variables['catalog_item'] = $variables['elements']['#catalog_item'];
  /** @var \Drupal\catalog_item\CatalogItemInterface $catalog_item */
  $catalog_item = $variables['catalog_item'];
  $skip_custom_preprocessing = $catalog_item->getEntityType()->get('enable_base_field_custom_preprocess_skipping');

  // Make created, uid and title fields available separately. Skip this custom
  // preprocessing if the field display is configurable and skipping has been
  // enabled.
  // @todo https://www.drupal.org/project/drupal/issues/3015623
  //   Eventually delete this code and matching template lines. Using
  //   $variables['content'] is more flexible and consistent.
  $submitted_configurable = $catalog_item->getFieldDefinition('created')->isDisplayConfigurable('view') || $catalog_item->getFieldDefinition('uid')->isDisplayConfigurable('view');
  if (!$skip_custom_preprocessing || !$submitted_configurable) {
    $variables['date'] = \Drupal::service('renderer')->render($variables['elements']['created']);
    unset($variables['elements']['created']);
    $variables['curator_name'] = \Drupal::service('renderer')->render($variables['elements']['uid']);
    unset($variables['elements']['uid']);
  }

  if (!$skip_custom_preprocessing || !$catalog_item->getFieldDefinition('title')->isDisplayConfigurable('view')) {
    $variables['label'] = $variables['elements']['title'];
    unset($variables['elements']['title']);
  }

  $variables['url'] = !$catalog_item->isNew() ? $catalog_item->toUrl('canonical')->toString() : NULL;

  // The 'page' variable is set to TRUE in two occasions:
  //   - The view mode is 'full' and we are on the 'catalog_item.view' route.
  //   - The catalog_item is in preview and view mode is either 'full' or 'default'.
  $variables['page'] = ($variables['view_mode'] == 'full' && (catalog_item_is_page($catalog_item)) || (isset($catalog_item->in_preview) && in_array($catalog_item->preview_view_mode, ['full', 'default'])));

  // Helpful $content variable for templates.
  $variables += ['content' => []];
  foreach (Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  if (isset($variables['date'])) {
    // Display post information on certain catalog_item types. This only occurs if
    // custom preprocessing occurred for both of the created and uid fields.
    // @todo https://www.drupal.org/project/drupal/issues/3015623
    //   Eventually delete this code and matching template lines. Using a field
    //   formatter is more flexible and consistent.
    /**
     *  catalag vs type @HERE
     */
    $catalog = $catalog_item->catalog->entity;
    // Used by RDF to add attributes around the author and date submitted.
    $variables['curator_attributes'] = new Attribute();
    $variables['display_submitted'] = $catalog->displaySubmitted();
    if ($variables['display_submitted']) {
      if (theme_get_setting('features.catalog_item_user_picture')) {
        // To change user picture settings (e.g. image style), edit the
        // 'compact' view mode on the User entity. Note that the 'compact'
        // view mode might not be configured, so remember to always check the
        // theme setting first.
        $variables['curator_picture'] = \Drupal::entityTypeManager()
          ->getViewBuilder('user')
          ->view($catalog_item->getOwner(), 'compact');
      }
    }
  }

  // Add article ARIA role.
  $variables['attributes']['role'] = 'article';
}

/**
 * Implements hook_cron().
 */
function catalog_item_cron() {
  // Calculate the oldest and newest catalog_item created times, for use in search
  // rankings. (Note that field aliases have to be variables passed by
  // reference.)
  if (\Drupal::moduleHandler()->moduleExists('search')) {
    $min_alias = 'min_created';
    $max_alias = 'max_created';
    $result = \Drupal::entityQueryAggregate('catalog_item')
      ->aggregate('created', 'MIN', NULL, $min_alias)
      ->aggregate('created', 'MAX', NULL, $max_alias)
      ->execute();
    if (isset($result[0])) {
      // Make an array with definite keys and store it in the state system.
      $array = [
        'min_created' => $result[0][$min_alias],
        'max_created' => $result[0][$max_alias],
      ];
      \Drupal::state()->set('catalog_item.min_max_update_time', $array);
    }
  }
}

/**
 * Implements hook_ranking().
 */
function catalog_item_ranking() {
  // Create the ranking array and add the basic ranking options.
  $ranking = [
    'relevance' => [
      'title' => t('Keyword relevance'),
      // Average relevance values hover around 0.15
      'score' => 'i.relevance',
    ],
    'sticky' => [
      'title' => t('Content is sticky at top of lists'),
      // The sticky flag is either 0 or 1, which is automatically normalized.
      'score' => 'c.sticky',
    ],
    'promote' => [
      'title' => t('Content is promoted to the front page'),
      // The promote flag is either 0 or 1, which is automatically normalized.
      'score' => 'c.promote',
    ],
  ];
  // Add relevance based on updated date, but only if it the scale values have
  // been calculated in catalog_item_cron().
  if ($catalog_item_min_max = \Drupal::state()->get('catalog_item.min_max_update_time')) {
    $ranking['recent'] = [
      'title' => t('Recently created'),
      // Exponential decay with half life of 14% of the age range of catalog_items.
      'score' => 'EXP(-5 * (1 - (c.created - :catalog_item_oldest) / :catalog_item_range))',
      'arguments' => [
        ':catalog_item_oldest' => $catalog_item_min_max['min_created'],
        ':catalog_item_range' => max($catalog_item_min_max['max_created'] - $catalog_item_min_max['min_created'], 1),
      ],
    ];
  }
  return $ranking;
}

/**
 * Implements hook_user_cancel().
 */
function catalog_item_user_cancel($edit, UserInterface $account, $method) {
  switch ($method) {
    case 'user_cancel_block_unpublish':
      // Unpublish catalog_items (current revisions).
      $nids = \Drupal::entityQuery('catalog_item')
        ->condition('uid', $account->id())
        ->execute();
      module_load_include('inc', 'catalog_item', 'catalog_item.admin');
      catalog_item_mass_update($nids, ['status' => 0], NULL, TRUE);
      break;

    case 'user_cancel_reassign':
      // Anonymize all of the catalog_items for this old account.
      module_load_include('inc', 'catalog_item', 'catalog_item.admin');
      $vids = \Drupal::entityTypeManager()->getStorage('catalog_item')->userRevisionIds($account);
      catalog_item_mass_update($vids, [
        'uid' => 0,
        'revision_uid' => 0,
      ], NULL, TRUE, TRUE);
      break;
  }
}

/**
 * Implements hook_ENTITY_TYPE_predelete() for user entities.
 */
function catalog_item_user_predelete($account) {
  // Delete catalog_items (current revisions).
  // @todo Introduce catalog_item_mass_delete() or make catalog_item_mass_update() more flexible.
  $nids = \Drupal::entityQuery('catalog_item')
    ->condition('uid', $account->id())
    ->accessCheck(FALSE)
    ->execute();
  // Delete old revisions.
  $storage_controller = \Drupal::entityTypeManager()->getStorage('catalog_item');
  $catalog_items = $storage_controller->loadMultiple($nids);
  $storage_controller->delete($catalog_items);
  $revisions = $storage_controller->userRevisionIds($account);
  foreach ($revisions as $revision) {
    catalog_item_revision_delete($revision);
  }
}

/**
 * Finds the most recently changed catalog_items that are available to the current user.
 *
 * @param $number
 *   (optional) The maximum number of catalog_items to find. Defaults to 10.
 *
 * @return \Drupal\catalog_item\CatalogItemInterface[]
 *   An array of catalog_item entities or an empty array if there are no recent catalog_items
 *   visible to the current user.
 */
function catalog_item_get_recent($number = 10) {
  $account = \Drupal::currentUser();
  $query = \Drupal::entityQuery('catalog_item');

  if (!$account->hasPermission('bypass catalog access')) {
    // If the user is able to view their own unpublished catalog_items, allow them
    // to see these in addition to published catalog_items. Check that they actually
    // have some unpublished catalog_items to view before adding the condition.
    $access_query = \Drupal::entityQuery('catalog_item')
      ->condition('uid', $account->id())
      ->condition('status', CatalogItemInterface::NOT_PUBLISHED);
    if ($account->hasPermission('view own unpublished catalog items') && ($own_unpublished = $access_query->execute())) {
      $query->orConditionGroup()
        ->condition('status', CatalogItemInterface::PUBLISHED)
        ->condition('nid', $own_unpublished, 'IN');
    }
    else {
      // If not, restrict the query to published catalog_items.
      $query->condition('status', CatalogItemInterface::PUBLISHED);
    }
  }
  $nids = $query
    ->sort('changed', 'DESC')
    ->range(0, $number)
    ->addTag('catalog_item_access')
    ->execute();

  $catalog_items = CatalogItem::loadMultiple($nids);

  return $catalog_items ? $catalog_items : [];
}

// /**
//  * Generates an array for rendering the given catalog_item.
//  *
//  * @param \Drupal\catalog_item\CatalogItemInterface $catalog_item
//  *   A catalog_item entity.
//  * @param $view_mode
//  *   (optional) View mode, e.g., 'full', 'teaser', etc. Defaults to 'full.'
//  * @param $langcode
//  *   (optional) A language code to use for rendering. Defaults to NULL which is
//  *   the global content language of the current request.
//  *
//  * @return array
//  *   An array as expected by \Drupal\Core\Render\RendererInterface::render().
//  *
//  * @deprecated in drupal:8.7.0 and is removed from drupal:9.0.0.
//  *   Use \Drupal::entityTypeManager()->getViewBuilder('catalog_item')->view() instead.
//  *
//  * @see https://www.drupal.org/catalog_item/3033656
//  */
// function catalog_item_view(CatalogItemInterface $catalog_item, $view_mode = 'full', $langcode = NULL) {
//   @trigger_error("catalog_item_view() is deprecated in Drupal 8.7.0 and will be removed before Drupal 9.0.0. Use \Drupal::entityTypeManager()->getViewBuilder('catalog_item')->view() instead. See https://www.drupal.org/catalog_item/3033656", E_USER_DEPRECATED);
//   return \Drupal::entityTypeManager()
//     ->getViewBuilder('catalog_item')
//     ->view($catalog_item, $view_mode, $langcode);
// }

// /**
//  * Constructs a drupal_render() style array from an array of loaded catalog_items.
//  *
//  * @param $catalog_items
//  *   An array of catalog_items as returned by CatalogItem::loadMultiple().
//  * @param $view_mode
//  *   (optional) View mode, e.g., 'full', 'teaser', etc. Defaults to 'teaser.'
//  * @param $langcode
//  *   (optional) A language code to use for rendering. Defaults to the global
//  *   content language of the current request.
//  *
//  * @return array
//  *   An array in the format expected by
//  *   \Drupal\Core\Render\RendererInterface::render().
//  *
//  * @deprecated in drupal:8.7.0 and is removed from drupal:9.0.0. Use
//  *   \Drupal::entityTypeManager()->getViewBuilder('catalog_item')->viewMultiple()
//  *   instead.
//  *
//  * @see https://www.drupal.org/catalog_item/3033656
//  */
// function catalog_item_view_multiple($catalog_items, $view_mode = 'teaser', $langcode = NULL) {
//   @trigger_error("catalog_item_view_multiple() is deprecated in Drupal 8.7.0 and will be removed before Drupal 9.0.0. Use \Drupal::entityTypeManager()->getViewBuilder('catalog_item')->viewMultiple() instead. See https://www.drupal.org/catalog_item/3033656", E_USER_DEPRECATED);
//   return \Drupal::entityTypeManager()
//     ->getViewBuilder('catalog_item')
//     ->viewMultiple($catalog_items, $view_mode, $langcode);
// }

/**
 * Implements hook_page_top().
 */
function catalog_item_page_top(array &$page) {
  // Add 'Back to content editing' link on preview page.
  $route_match = \Drupal::routeMatch();
  if ($route_match->getRouteName() == 'entity.catalog_item.preview') {
    $page['page_top']['catalog_item_preview'] = [
      '#type' => 'container',
      '#attributes' => [
        'class' => ['catalog_item-preview-container', 'container-inline'],
      ],
    ];

    $form = \Drupal::formBuilder()->getForm('\Drupal\catalog_item\Form\CatalogItemPreviewForm', $route_match->getParameter('catalog_item_preview'));
    $page['page_top']['catalog_item_preview']['view_mode'] = $form;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters the theme form to use the admin theme on catalog_item editing.
 *
 * @see catalog_item_form_system_themes_admin_form_submit()
 */
function catalog_item_form_system_themes_admin_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['admin_theme']['catalog_use_admin_theme'] = [
    '#type' => 'checkbox',
    '#title' => t('Use the administration theme when editing or creating catalog items'),
    '#description' => t('Control which roles can "View the administration theme" on the <a href=":permissions">Permissions page</a>.', [':permissions' => Url::fromRoute('user.admin_permissions')->toString()]),
    '#default_value' => \Drupal::configFactory()->getEditable('catalog_item.settings')->get('catalog_use_admin_theme'),
  ];
  $form['#submit'][] = 'catalog_item_form_system_themes_admin_form_submit';
}

/**
 * Form submission handler for system_themes_admin_form().
 *
 * @see catalog_item_form_system_themes_admin_form_alter()
 */
function catalog_item_form_system_themes_admin_form_submit($form, FormStateInterface $form_state) {
  \Drupal::configFactory()->getEditable('catalog_item.settings')
    ->set('catalog_use_admin_theme', $form_state->getValue('catalog_use_admin_theme'))
    ->save();
}

/**
 * @defgroup catalog_item_access CatalogItem access rights
 * @{
 * The catalog_item access system determines who can do what to which catalog_items.
 *
 * In determining access rights for a catalog_item, \Drupal\catalog_item\CatalogItemAccessControlHandler
 * first checks whether the user has the "bypass catalog access" permission. Such
 * users have unrestricted access to all catalog_items. user 1 will always pass this
 * check.
 *
 * Next, all implementations of hook_catalog_item_access() will be called. Each
 * implementation may explicitly allow, explicitly forbid, or ignore the access
 * request. If at least one module says to forbid the request, it will be
 * rejected. If no modules deny the request and at least one says to allow it,
 * the request will be permitted.
 *
 * If all modules ignore the access request, then the catalog_item_access table is used
 * to determine access. All catalog_item access modules are queried using
 * hook_catalog_item_grants() to assemble a list of "grant IDs" for the user. This list
 * is compared against the table. If any row contains the catalog_item ID in question
 * (or 0, which stands for "all catalog_items"), one of the grant IDs returned, and a
 * value of TRUE for the operation in question, then access is granted. Note
 * that this table is a list of grants; any matching row is sufficient to grant
 * access to the catalog_item.
 *
 * In catalog_item listings (lists of catalog_items generated from a select query, such as the
 * default home page at path 'catalog_item', an RSS feed, a recent content block, etc.),
 * the process above is followed except that hook_catalog_item_access() is not called on
 * each catalog_item for performance reasons and for proper functioning of the pager
 * system. When adding a catalog_item listing to your module, be sure to use an entity
 * query, which will add a tag of "catalog_item_access". This will allow modules dealing
 * with catalog_item access to ensure only catalog_items to which the user has access are
 * retrieved, through the use of hook_query_TAG_alter(). See the
 * @link entity_api Entity API topic @endlink for more information on entity
 * queries. Tagging a query with "catalog_item_access" does not check the
 * published/unpublished status of catalog_items, so the base query is responsible
 * for ensuring that unpublished catalog_items are not displayed to inappropriate users.
 *
 * Note: Even a single module returning an AccessResultInterface object from
 * hook_catalog_item_access() whose isForbidden() method equals TRUE will block access
 * to the catalog_item. Therefore, implementers should take care to not deny access
 * unless they really intend to. Unless a module wishes to actively forbid
 * access it should return an AccessResultInterface object whose isAllowed() nor
 * isForbidden() methods return TRUE, to allow other modules or the catalog_item_access
 * table to control access.
 *
 * To see how to write a catalog_item access module of your own, see
 * catalog_item_access_example.module.
 */

/**
 * Implements hook_catalog_item_access().
 */
function catalog_item_catalog_item_access(CatalogItemInterface $catalog_item, $op, AccountInterface $account) {
  $type = $catalog_item->bundle();
  $access = AccessResult::neutral();

  switch ($op) {
    case 'create':
      $access = AccessResult::allowedIfHasPermission($account, 'create ' . $type . ' catalog items');

    case 'update':
      $access = AccessResult::allowedIfHasPermission($account, 'edit any ' . $type . ' catalog items');
      if (!$access->isAllowed() && $account->hasPermission('edit own ' . $type . ' catalog items')) {
        $access = $access->orIf(AccessResult::allowedIf($account->id() == $catalog_item->getOwnerId())->cachePerUser()->addCacheableDependency($catalog_item));
      }
      break;

    case 'delete':
      $access = AccessResult::allowedIfHasPermission($account, 'delete any ' . $type . ' catalog items');
      if (!$access->isAllowed() && $account->hasPermission('delete own ' . $type . ' catalog items')) {
        $access = $access->orIf(AccessResult::allowedIf($account->id() == $catalog_item->getOwnerId()))->cachePerUser()->addCacheableDependency($catalog_item);
      }
      break;
  }

  return $access;
}

/**
 * Fetches an array of permission IDs granted to the given user ID.
 *
 * The implementation here provides only the universal "all" grant. A catalog_item
 * access module should implement hook_catalog_item_grants() to provide a grant list for
 * the user.
 *
 * After the default grants have been loaded, we allow modules to alter the
 * grants array by reference. This hook allows for complex business logic to be
 * applied when integrating multiple catalog_item access modules.
 *
 * @param string $op
 *   The operation that the user is trying to perform.
 * @param \Drupal\Core\Session\AccountInterface $account
 *   The account object for the user performing the operation.
 *
 * @return array
 *   An associative array in which the keys are realms, and the values are
 *   arrays of grants for those realms.
 */
function catalog_item_access_grants($op, AccountInterface $account) {
  // Fetch catalog_item access grants from other modules.
  $grants = \Drupal::moduleHandler()->invokeAll('catalog_item_grants', [$account, $op]);
  // Allow modules to alter the assigned grants.
  \Drupal::moduleHandler()->alter('catalog_item_grants', $grants, $account, $op);

  return array_merge(['all' => [0]], $grants);
}

/**
 * Determines whether the user has a global viewing grant for all catalog_items.
 *
 * Checks to see whether any module grants global 'view' access to a user
 * account; global 'view' access is encoded in the {catalog_item_access} table as a
 * grant with nid=0. If no catalog_item access modules are enabled, catalog_item.module defines
 * such a global 'view' access grant.
 *
 * This function is called when a catalog_item listing query is tagged with
 * 'catalog_item_access'; when this function returns TRUE, no catalog_item access joins are
 * added to the query.
 *
 * @param $account
 *   (optional) The user object for the user whose access is being checked. If
 *   omitted, the current user is used. Defaults to NULL.
 *
 * @return
 *   TRUE if 'view' access to all catalog_items is granted, FALSE otherwise.
 *
 * @see hook_catalog_item_grants()
 * @see catalog_item_query_catalog_item_access_alter()
 */
function catalog_item_access_view_all_catalog_items($account = NULL) {

  if (!$account) {
    $account = \Drupal::currentUser();
  }

  // Statically cache results in an array keyed by $account->id().
  $access = &drupal_static(__FUNCTION__);
  if (isset($access[$account->id()])) {
    return $access[$account->id()];
  }

  // If no modules implement the catalog_item access system, access is always TRUE.
  if (!\Drupal::moduleHandler()->getImplementations('catalog_item_grants')) {
    $access[$account->id()] = TRUE;
  }
  else {
    $access[$account->id()] = \Drupal::entityTypeManager()->getAccessControlHandler('catalog_item')->checkAllGrants($account);
  }

  return $access[$account->id()];
}

/**
 * Implements hook_query_TAG_alter().
 *
 * This is the hook_query_alter() for queries tagged with 'catalog_item_access'. It adds
 * catalog_item access checks for the user account given by the 'account' meta-data (or
 * current user if not provided), for an operation given by the 'op' meta-data
 * (or 'view' if not provided; other possible values are 'update' and 'delete').
 *
 * Queries tagged with 'catalog_item_access' that are not against the {catalog_item} table
 * must add the base table as metadata. For example:
 * @code
 *   $query
 *     ->addTag('catalog_item_access')
 *     ->addMetaData('base_table', 'catalog_taxonomy_index');
 * @endcode
 */
function catalog_item_query_catalog_item_access_alter(AlterableInterface $query) {
  // Read meta-data from query, if provided.
  if (!$account = $query->getMetaData('account')) {
    $account = \Drupal::currentUser();
  }
  if (!$op = $query->getMetaData('op')) {
    $op = 'view';
  }

  // If $account can bypass catalog access, or there are no catalog_item access modules,
  // or the operation is 'view' and the $account has a global view grant
  // (such as a view grant for catalog_item ID 0), we don't need to alter the query.
  if ($account->hasPermission('bypass catalog access')) {
    return;
  }
  if (!count(\Drupal::moduleHandler()->getImplementations('catalog_item_grants'))) {
    return;
  }
  if ($op == 'view' && catalog_item_access_view_all_catalog_items($account)) {
    return;
  }

  $tables = $query->getTables();
  $base_table = $query->getMetaData('base_table');
  // If the base table is not given, default to one of the catalog_item base tables.
  if (!$base_table) {
    /** @var \Drupal\Core\Entity\Sql\DefaultTableMapping $table_mapping */
    $table_mapping = \Drupal::entityTypeManager()->getStorage('catalog_item')->getTableMapping();
    $catalog_item_base_tables = $table_mapping->getTableNames();

    foreach ($tables as $table_info) {
      if (!($table_info instanceof SelectInterface)) {
        $table = $table_info['table'];
        // Ensure that 'catalog_item' and 'catalog_item_field_data' are always preferred over
        // 'catalog_item_revision' and 'catalog_item_field_revision'.
        if ($table == 'catalog_item' || $table == 'catalog_item_field_data') {
          $base_table = $table;
          break;
        }
        // If one of the catalog_item base tables are in the query, add it to the list
        // of possible base tables to join against.
        if (in_array($table, $catalog_item_base_tables)) {
          $base_table = $table;
        }
      }
    }

    // Bail out if the base table is missing.
    if (!$base_table) {
      throw new Exception(t('Query tagged for catalog_item access but there is no catalog_item table, specify the base_table using meta data.'));
    }
  }

  // Update the query for the given storage method.
  \Drupal::service('catalog_item.grant_storage')->alterQuery($query, $tables, $op, $account, $base_table);

  // Bubble the 'user.catalog_item_grants:$op' cache context to the current render
  // context.
  $request = \Drupal::requestStack()->getCurrentRequest();
  $renderer = \Drupal::service('renderer');
  if ($request->isMethodCacheable() && $renderer->hasRenderContext()) {
    $build = ['#cache' => ['contexts' => ['user.catalog_item_grants:' . $op]]];
    $renderer->render($build);
  }
}

/**
 * Toggles or reads the value of a flag for rebuilding the catalog_item access grants.
 *
 * When the flag is set, a message is displayed to users with 'access
 * administration pages' permission, pointing to the 'rebuild' confirm form.
 * This can be used as an alternative to direct catalog_item_access_rebuild calls,
 * allowing administrators to decide when they want to perform the actual
 * (possibly time consuming) rebuild.
 *
 * When unsure if the current user is an administrator, catalog_item_access_rebuild()
 * should be used instead.
 *
 * @param $rebuild
 *   (optional) The boolean value to be written.
 *
 * @return bool|null
 *   The current value of the flag if no value was provided for $rebuild. If a
 *   value was provided for $rebuild, nothing (NULL) is returned.
 *
 * @see catalog_item_access_rebuild()
 */
function catalog_item_access_needs_rebuild($rebuild = NULL) {
  if (!isset($rebuild)) {
    return \Drupal::state()->get('catalog_item.catalog_item_access_needs_rebuild') ?: FALSE;
  }
  elseif ($rebuild) {
    \Drupal::state()->set('catalog_item.catalog_item_access_needs_rebuild', TRUE);
  }
  else {
    \Drupal::state()->delete('catalog_item.catalog_item_access_needs_rebuild');
  }
}

/**
 * Rebuilds the catalog_item access database.
 *
 * This rebuild is occasionally needed by modules that make system-wide changes
 * to access levels. When the rebuild is required by an admin-triggered action
 * (e.g module settings form), calling catalog_item_access_needs_rebuild(TRUE) instead
 * of catalog_item_access_rebuild() lets the user perform changes and actually rebuild
 * only once done.
 *
 * Note : As of Drupal 6, catalog_item access modules are not required to (and actually
 * should not) call catalog_item_access_rebuild() in hook_install/uninstall anymore.
 *
 * @param $batch_mode
 *   (optional) Set to TRUE to process in 'batch' mode, spawning processing over
 *   several HTTP requests (thus avoiding the risk of PHP timeout if the site
 *   has a large number of catalog_items). hook_update_N() and any form submit handler
 *   are safe contexts to use the 'batch mode'. Less decidable cases (such as
 *   calls from hook_user(), hook_taxonomy(), etc.) might consider using the
 *   non-batch mode. Defaults to FALSE.
 *
 * @see catalog_item_access_needs_rebuild()
 */
function catalog_item_access_rebuild($batch_mode = FALSE) {
  $catalog_item_storage = \Drupal::entityTypeManager()->getStorage('catalog_item');
  /** @var \Drupal\catalog_item\CatalogItemAccessControlHandlerInterface $access_control_handler */
  $access_control_handler = \Drupal::entityTypeManager()->getAccessControlHandler('catalog_item');
  $access_control_handler->deleteGrants();
  // Only recalculate if the site is using a catalog_item_access module.
  if (count(\Drupal::moduleHandler()->getImplementations('catalog_item_grants'))) {
    if ($batch_mode) {
      $batch = [
        'title' => t('Rebuilding catalog access permissions'),
        'operations' => [
          ['_catalog_item_access_rebuild_batch_operation', []],
        ],
        'finished' => '_catalog_item_access_rebuild_batch_finished',
      ];
      batch_set($batch);
    }
    else {
      // Try to allocate enough time to rebuild catalog_item grants
      Environment::setTimeLimit(240);

      // Rebuild newest catalog_items first so that recent content becomes available
      // quickly.
      $entity_query = \Drupal::entityQuery('catalog_item');
      $entity_query->sort('nid', 'DESC');
      // Disable access checking since all catalog_items must be processed even if the
      // user does not have access. And unless the current user has the bypass
      // catalog_item access permission, no catalog_items are accessible since the grants have
      // just been deleted.
      $entity_query->accessCheck(FALSE);
      $nids = $entity_query->execute();
      foreach ($nids as $nid) {
        $catalog_item_storage->resetCache([$nid]);
        $catalog_item = CatalogItem::load($nid);
        // To preserve database integrity, only write grants if the catalog_item
        // loads successfully.
        if (!empty($catalog_item)) {
          $grants = $access_control_handler->acquireGrants($catalog_item);
          \Drupal::service('catalog_item.grant_storage')->write($catalog_item, $grants);
        }
      }
    }
  }
  else {
    // Not using any catalog_item_access modules. Add the default grant.
    $access_control_handler->writeDefaultGrant();
  }

  if (!isset($batch)) {
    \Drupal::messenger()->addStatus(t('Catalog permissions have been rebuilt.'));
    catalog_item_access_needs_rebuild(FALSE);
  }
}

/**
 * Implements callback_batch_operation().
 *
 * Performs batch operation for catalog_item_access_rebuild().
 *
 * This is a multistep operation: we go through all catalog_items by packs of 20. The
 * batch processing engine interrupts processing and sends progress feedback
 * after 1 second execution time.
 *
 * @param array $context
 *   An array of contextual key/value information for rebuild batch process.
 */
function _catalog_item_access_rebuild_batch_operation(&$context) {
  $catalog_item_storage = \Drupal::entityTypeManager()->getStorage('catalog_item');
  if (empty($context['sandbox'])) {
    // Initiate multistep processing.
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_catalog_item'] = 0;
    $context['sandbox']['max'] = \Drupal::entityQuery('catalog_item')->accessCheck(FALSE)->count()->execute();
  }

  // Process the next 20 catalog_items.
  $limit = 20;
  $nids = \Drupal::entityQuery('catalog_item')
    ->condition('nid', $context['sandbox']['current_catalog_item'], '>')
    ->sort('nid', 'ASC')
    // Disable access checking since all catalog_items must be processed even if the
    // user does not have access. And unless the current user has the bypass
    // catalog_item access permission, no catalog_items are accessible since the grants have
    // just been deleted.
    ->accessCheck(FALSE)
    ->range(0, $limit)
    ->execute();
  $catalog_item_storage->resetCache($nids);
  $catalog_items = CatalogItem::loadMultiple($nids);
  foreach ($catalog_items as $nid => $catalog_item) {
    // To preserve database integrity, only write grants if the catalog_item
    // loads successfully.
    if (!empty($catalog_item)) {
      /** @var \Drupal\catalog_item\CatalogItemAccessControlHandlerInterface $access_control_handler */
      $access_control_handler = \Drupal::entityTypeManager()->getAccessControlHandler('catalog_item');
      $grants = $access_control_handler->acquireGrants($catalog_item);
      \Drupal::service('catalog_item.grant_storage')->write($catalog_item, $grants);
    }
    $context['sandbox']['progress']++;
    $context['sandbox']['current_catalog_item'] = $nid;
  }

  // Multistep processing : report progress.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Implements callback_batch_finished().
 *
 * Performs post-processing for catalog_item_access_rebuild().
 *
 * @param bool $success
 *   A boolean indicating whether the re-build process has completed.
 * @param array $results
 *   An array of results information.
 * @param array $operations
 *   An array of function calls (not used in this function).
 */
function _catalog_item_access_rebuild_batch_finished($success, $results, $operations) {
  if ($success) {
    \Drupal::messenger()->addStatus(t('The catalog access permissions have been rebuilt.'));
    catalog_item_access_needs_rebuild(FALSE);
  }
  else {
    \Drupal::messenger()->addError(t('The catalog access permissions have not been properly rebuilt.'));
  }
}

/**
 * @} End of "defgroup catalog_item_access".
 */

/**
 * Implements hook_modules_installed().
 */
function catalog_item_modules_installed($modules) {
  // Check if any of the newly enabled modules require the catalog_item_access table to
  // be rebuilt.
  if (!catalog_item_access_needs_rebuild() && array_intersect($modules, \Drupal::moduleHandler()->getImplementations('catalog_item_grants'))) {
    catalog_item_access_needs_rebuild(TRUE);
  }
}

/**
 * Implements hook_modules_uninstalled().
 */
function catalog_item_modules_uninstalled($modules) {
  // Check whether any of the disabled modules implemented hook_catalog_item_grants(),
  // in which case the catalog_item access table needs to be rebuilt.
  foreach ($modules as $module) {
    // At this point, the module is already disabled, but its code is still
    // loaded in memory. Module functions must no longer be called. We only
    // check whether a hook implementation function exists and do not invoke it.
    // CatalogItem access also needs to be rebuilt if language module is disabled to
    // remove any language-specific grants.
    if (!catalog_item_access_needs_rebuild() && (\Drupal::moduleHandler()->implementsHook($module, 'catalog_item_grants') || $module == 'language')) {
      catalog_item_access_needs_rebuild(TRUE);
    }
  }

  // If there remains no more catalog_item_access module, rebuilding will be
  // straightforward, we can do it right now.
  if (catalog_item_access_needs_rebuild() && count(\Drupal::moduleHandler()->getImplementations('catalog_item_grants')) == 0) {
    catalog_item_access_rebuild();
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete() for 'configurable_language'.
 */
function catalog_item_configurable_language_delete(ConfigurableLanguageInterface $language) {
  // On catalog_items with this language, unset the language.
  \Drupal::entityTypeManager()->getStorage('catalog_item')->clearRevisionsLanguage($language);
}

/**
 * Marks a catalog_item to be re-indexed by the catalog_item_search plugin.
 *
 * @param int $nid
 *   The catalog_item ID.
 */
function catalog_item_reindex_catalog_item_search($nid) {
  if (\Drupal::moduleHandler()->moduleExists('search')) {
    // Reindex catalog_item context indexed by the catalog_item module search plugin.
    \Drupal::service('search.index')->markForReindex('catalog_item_search', $nid);
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert() for comment entities.
 */
function catalog_item_comment_insert($comment) {
  // Reindex the catalog_item when comments are added.
  if ($comment->getCommentedEntityTypeId() == 'catalog_item') {
    catalog_item_reindex_catalog_item_search($comment->getCommentedEntityId());
  }
}

/**
 * Implements hook_ENTITY_TYPE_update() for comment entities.
 */
function catalog_item_comment_update($comment) {
  // Reindex the catalog_item when comments are changed.
  if ($comment->getCommentedEntityTypeId() == 'catalog_item') {
    catalog_item_reindex_catalog_item_search($comment->getCommentedEntityId());
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete() for comment entities.
 */
function catalog_item_comment_delete($comment) {
  // Reindex the catalog_item when comments are deleted.
  if ($comment->getCommentedEntityTypeId() == 'catalog_item') {
    catalog_item_reindex_catalog_item_search($comment->getCommentedEntityId());
  }
}

/**
 * Implements hook_config_translation_info_alter().
 */
function catalog_item_config_translation_info_alter(&$info) {
  $info['catalog']['class'] = 'Drupal\catalog_item\ConfigTranslation\CatalogMapper';
}

/**
 * @defgroup catalog_taxonomy_index Taxonomy indexing
 * @{
 * Functions to maintain taxonomy indexing.
 *
 * Taxonomy uses default field storage to store canonical relationships
 * between terms and fieldable entities. However its most common use case
 * requires listing all content associated with a term or group of terms
 * sorted by creation date. To avoid slow queries due to joining across
 * multiple catalog_item and field tables with various conditions and order by criteria,
 * we maintain a denormalized table with all relationships between terms,
 * published catalog_items and common sort criteria such as status, sticky and created.
 * When using other field storage engines or alternative methods of
 * denormalizing this data you should set the
 * taxonomy.settings:maintain_index_table to '0' to avoid unnecessary writes in
 * SQL.
 */

/**
 * Implements hook_ENTITY_TYPE_insert() for catalog_item entities.
 */
function catalog_item_catalog_item_insert($catalog_item) {
  // Add taxonomy index entries for the catalog_item.
  taxonomy_build_catalog_item_index($catalog_item);
}

/**
 * Builds and inserts taxonomy index entries for a given catalog_item.
 *
 * The index lists all terms that are related to a given catalog_item entity, and is
 * therefore maintained at the entity level.
 *
 * @param \Drupal\catalog_item\Entity\CatalogItem $catalog_item
 *   The catalog_item entity.
 */
function taxonomy_build_catalog_item_index($catalog_item) {
  // We maintain a denormalized table of term/catalog_item relationships, containing
  // only data for current, published catalog_items.
  if (!\Drupal::config('taxonomy.settings')->get('maintain_index_table') ) {
    //|| !(\Drupal::entityTypeManager()->getStorage('catalog_item') instanceof SqlContentEntityStorage)
    return;
  }

  $status = $catalog_item->isPublished();
  $sticky = (int) $catalog_item->isSticky();
  // We only maintain the taxonomy index for published catalog_items.
  if ($status && $catalog_item->isDefaultRevision()) {
    // Collect a unique list of all the term IDs from all catalog_item fields.
    $tid_all = [];
    $entity_reference_class = 'Drupal\Core\Field\Plugin\Field\FieldType\EntityReferenceItem';
    foreach ($catalog_item->getFieldDefinitions() as $field) {
      $field_name = $field->getName();
      $class = $field->getItemDefinition()->getClass();
      $is_entity_reference_class = ($class === $entity_reference_class) || is_subclass_of($class, $entity_reference_class);
      if ($is_entity_reference_class && $field->getSetting('target_type') == 'taxonomy_term') {
        foreach ($catalog_item->getTranslationLanguages() as $language) {
          foreach ($catalog_item->getTranslation($language->getId())->$field_name as $item) {
            if (!$item->isEmpty()) {
              $tid_all[$item->target_id] = $item->target_id;
            }
          }
        }
      }
    }
    // Insert index entries for all the catalog_item's terms.
    if (!empty($tid_all)) {
      $connection = \Drupal::database();
      foreach ($tid_all as $tid) {
        $connection->merge('catalog_taxonomy_index')
          ->key(['nid' => $catalog_item->id(), 'tid' => $tid, 'status' => $catalog_item->isPublished()])
          ->fields(['sticky' => $sticky, 'created' => $catalog_item->getCreatedTime()])
          ->execute();
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update() for catalog_item entities.
 */
function catalog_item_catalog_item_update($catalog_item) {
  \Drupal::logger('catalog_item')->error('Catalog Item @label updating....', array(
    '@label'  => $catalog_item->id(),
  ));
  // If we're not dealing with the default revision of the catalog_item, do not make any
  // change to the taxonomy index.
  if (!$catalog_item->isDefaultRevision()) {
    \Drupal::logger('catalog_item')->error('Catalog Item @label not default revision.');
    return;
  }
  taxonomy_delete_catalog_item_index($catalog_item);
  taxonomy_build_catalog_item_index($catalog_item);
}

/**
 * Implements hook_ENTITY_TYPE_predelete() for catalog_item entities.
 */
function catalog_item_catalog_item_predelete($catalog_item) {
  // Clean up the {catalog_taxonomy_index} table when catalog_items are deleted.
  taxonomy_delete_catalog_item_index($catalog_item);
}

/**
 * Deletes taxonomy index entries for a given catalog_item.
 *
 * @param \Drupal\Core\Entity\EntityInterface $catalog_item
 *   The catalog_item entity.
 */
function taxonomy_delete_catalog_item_index($catalog_item) {
  \Drupal::logger('catalog_item')->error('Attempting delete... @label', array(
    '@label'  => $catalog_item->id(),
  ));
  if (\Drupal::config('taxonomy.settings')->get('maintain_index_table')) {
    \Drupal::logger('catalog_item')->error('Deleting index for @label ....', array(
      '@label'  => $catalog_item->id(),
    ));
    \Drupal::database()->delete('catalog_taxonomy_index')->condition('nid', $catalog_item->id())->execute();
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete() for taxonomy_term entities.
 */
function catalog_item_taxonomy_term_delete($term) {
  if (\Drupal::config('taxonomy.settings')->get('maintain_index_table')) {
    // Clean up the {catalog_taxonomy_index} table when terms are deleted.
    \Drupal::database()->delete('catalog_taxonomy_index')->condition('tid', $term->id())->execute();
  }
}

/**
 * @} End of "defgroup catalog_taxonomy_index".
 */
 /**
   * Returns all terms used to tag some given catalog_items.
   *
   * @param array $nids
   *   Catalog_item IDs to retrieve terms for.
   * @param array $vocabs
   *   (optional) A vocabularies array to restrict the term search. Defaults to
   *   empty array.
   * @param string $langcode
   *   (optional) A language code to restrict the term search. Defaults to NULL.
   *
   * @return array
   *   An array of nids and the term entities they were tagged with.
   */
function getCatalogItemTerms(array $nids, array $vocabs = [], $langcode = NULL){
  $query = \Drupal::database()->select(\Drupal::entityTypeManager()->getStorage('taxonomy_term')->getDataTable(), 'td');
    $query->innerJoin('catalog_taxonomy_index', 'ctn', 'td.tid = ctn.tid');
    $query->fields('td', ['tid']);
    $query->addField('ctn', 'nid', 'catalog_item_nid');
    $query->orderby('td.weight');
    $query->orderby('td.name');
    $query->condition('ctn.nid', $nids, 'IN');
    $query->addTag('taxonomy_term_access');
    if (!empty($vocabs)) {
      $query->condition('td.vid', $vocabs, 'IN');
    }
    if (!empty($langcode)) {
      $query->condition('td.langcode', $langcode);
    }

    $results = [];
    $all_tids = [];
    foreach ($query->execute() as $term_record) {
      $results[$term_record->catalog_item_nid][] = $term_record->tid;
      $all_tids[] = $term_record->tid;
    }

    $all_terms = Term::loadMultiple($all_tids);
    $terms = [];
    foreach ($results as $nid => $tids) {
      foreach ($tids as $tid) {
        $terms[$nid][$tid] = $all_terms[$tid];
      }
    }
    return $terms;
}
